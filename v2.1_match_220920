<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://web-harvest.sourceforge.net/schema/1.0/config" scriptlang="groovy">

<secrets-vault-get alias="ebox" />

<var-def name="ph">
		<datastore name="public_holidays">
			SELECT * from @this
		</datastore>
</var-def>


<var-def name="links">
	<datastore name="sfi_refund">
		SELECT * FROM @this
	</datastore>
</var-def> 
	
	<robotics-flow>
<robot driver="universal" name="driver" start-in-private="false" close-on-completion="true">
			<capability name ="SEARCH_ALL_WINDOWS" value="true"/>
			<capability name="CLOSE_ALL_WINDOWS" value="false"/>
			
			
		<script><![CDATA[
		
			//robot checks for records for previous working day-->e.g FRI 24/07 robot puts criteria 23 12:00 AM and 24 12:00 AM, checks for IBK then compare with MA Files for 23
			
			//listings is also appending into hashmap->added listing condition before appeding to hashmap 07/08/20
			//date scenarios for morongwa query -- monday, public holiday, pwd falls on pevious month(previous working month) 11/08/20
			//getting issue while downloading morongwa excel -->button to be clicked might be disabled-->dynamic wait 12/08/20
			//account not matching if contains all numbers sometimes -- removed leading 0s 12/08/20 
			//search in MA Files 13/08/20
			//matched hashmap that containts search reference and amount if matched 14/08/20
			//search in 201 folder if not found in MA-->typically in "Q:\ROBOTICS\201 REPORTS\AUGUST\03\03 XXX\Reports\" 14/08/20
			//.201 file hardcoded where to get amount from-->it changes in each file-->dont hardcode loop through array to find DR or CR in array 17/08/20
			//scenario-->first record and fourth record in ref and amount array same
			//.201 getting duplicates(when there are more than one transaction with same acc no in same file) while verifying-->option 1-remove ref and amount from arrays after matched-->problem loop will get out of bounds because the loop size will be reduced
			//.201 if there are 2 identical records, duplicates will be caused in the loop-->use break after matched-->problem
			//.201 solution use boolean to indicate if already matched, then go to next line in text 17/08/20
			//added ebox array for records found on MA 25/08/20
			//second pwd for searching-->dynamic month and date search for 201 27/08/20 test further
			//add missing scenarios for account number 04/09/20
			//duplicates while searching in 201 files--> use array to store records obtained in MA only to compare with whle searching 201 27/08/20
			//delete morongwa excel after use or move to daily folder-->move default downloads to daily folder	09/09/20
			//201 ADD REFUND NARRATIVE TO 201 FILES-->used REFUND as narrative--temp 04/09/20
			//EBOX IF BIR, CHECK IF TRANSACTION DATE IS SAME OR ONE DAY BEFORE 04/09/20-->test further
			//EBOX if there are 2 transactions for the same date with the same amount--> taking both-->enter transaction to check for counterparty 16/09/20
			//EBOX counterparty acc num in swift are written manually, so sometimes it might miss some digits in front or at the end-->dont take last digit, compare with middle 6 digits 19/09/20 
			//ENTIRE check presence of swift excel 22/09/20
			
			//auth 21/08/20-->test further if key changes
					
			//search reference is name
			//MA Files will they be in monthly folders?
			
			
			//MORONGWA date scenario to run 1030 and 1600
			//201 search for latest date first--catered for date only not month 
			
			//date
			import java.time.LocalDate;
			import java.time.LocalDateTime;
			import java.time.ZoneId;
			import java.time.format.DateTimeFormatter
						
			//apache excel
			import org.apache.poi.xssf.usermodel.*;
			import org.apache.poi.ss.usermodel.*;
			import org.apache.poi.hssf.usermodel.*;
			import java.text.SimpleDateFormat;
			import org.apache.poi.ss.usermodel.DateUtil;
			
			//java string manipulation
			import java.text.DecimalFormat;
			import java.math.*; //big decimal
			
			//gAuth
			import com.warrenstrange.googleauth.GoogleAuthenticator;
			
			//rounding of double
			import java.math.RoundingMode;
			import java.text.DecimalFormat;
			
			//files	
			import org.apache.commons.io.FileUtils;
			import java.io.File;
			import java.io.FileInputStream;
			import java.io.FileOutputStream;
			import java.nio.file.FileSystem;
			import java.nio.file.FileSystems;
			import java.nio.file.Files;
			import java.nio.file.Path;
			import java.nio.file.StandardCopyOption;
			
			//sorting of array
			import java.util.Comparator;
			import org.apache.commons.lang.ArrayUtils;
			
			//DATE
			LocalDate karanLocal    = LocalDate.parse("2020-09-03"); 							
			//LocalDate karanLocal    = LocalDate.now()		
			LocalDate pwd		    = karanLocal.minusDays(1);										//live
			LocalDate second_pwd	= pwd.minusDays(1);
			LocalDateTime kLDT 		= LocalDateTime.now(ZoneId.of("GMT+04:00"));
			
			DateTimeFormatter csvDateFormat   = DateTimeFormatter.ofPattern("M/d/yyyy");
			DateTimeFormatter morongwaQueryDateFormat   = DateTimeFormatter.ofPattern("d");
			DateTimeFormatter MAFileDateFormat			= DateTimeFormatter.ofPattern("MMdd");
			DateTimeFormatter reports201DateFormat      = DateTimeFormatter.ofPattern("MMMM");
			DateTimeFormatter reports201subDateFormat   = DateTimeFormatter.ofPattern("dd");
			DateTimeFormatter eboxDateFormat     		= DateTimeFormatter.ofPattern("dd/MM/yy");
			DateTimeFormatter folder201DateFormat     	= DateTimeFormatter.ofPattern("MMMM-dd");
			DateTimeFormatter file201DateFormat     	= DateTimeFormatter.ofPattern("yyyy/MM/dd");
			
			
			//folder and file format
			DateTimeFormatter yearlyFolderFormat = DateTimeFormatter.ofPattern("YYYY");
			DateTimeFormatter monthlyFolderFormat = DateTimeFormatter.ofPattern("MM MMMM");
			DateTimeFormatter dailyFolderDateFormat = DateTimeFormatter.ofPattern("dd.MM.yy");
			String yearlyFolderStr = karanLocal.format(yearlyFolderFormat);
			String monthlyFolderStr = karanLocal.format(monthlyFolderFormat);
			String dailyFolderStr = karanLocal.format(dailyFolderDateFormat);
			DateTimeFormatter dateExcelFormat = DateTimeFormatter.ofPattern("MMMM "+"yyyy");
			String dateExcel  = karanLocal.format(dateExcelFormat);
			
			DateTimeFormatter MAFileBODateFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd");
			String tayme = karanLocal.toString() + " " + kLDT.getHour().toString()+ "_" + kLDT.getMinute().toString()
			
			////DATASTORE
			//DIRECTORY
			String Dir = links.get(0).getAt("path").toString();
			//EBOX PORTAL
			String ebox_portal = links.get(0).getAt("ebox_portal").toString();
			//MORONGWA LIVE
			String morongwa_live = links.get(0).getAt("morongwa_live").toString();
			//MAKOLA PORTAL
			String download_path = links.get(0).getAt("download_path").toString();
			//MA FOLDER PATH
			String MAFolder_path = links.get(0).getAt("MAFolder_path").toString()
			//201 REPORTS FOLDER
			String reports201_path = links.get(0).getAt("reports201_path").toString();
			
			//SECRETS VAULT
			Map entryMap = secureEntryMap.getWrappedObject();
			com.freedomoss.crowdcontrol.webharvest.web.dto.SecureEntryDTO obj = entryMap.get("ebox");
			ebox_login = obj.getKey().toString();
			ebox_pass = obj.getValue().toString();

		
			//PORTAL
			//String morongwa_uat = "https://celine-morongwa-uat.apps.nonprod.ocp.absa.co.za/#/";
			//String morongwa_live = "https://morongwa.prod.ocp.absa.co.za/#/";
			//String morongwa_login = "ABOR048";
			//String morongwa_pass = "Finger9.Ever,Forget854%%%";
			//String ebox_portal = "https://eboxprdcsc.corebanking.intra.absa.co.za/csc/login.jsp";
			//String ebox_login = "RB-MU_Robot_SFI_01";
			//String ebox_pass = "Wheeljack01";
			
			//PATH
			//String download_path = "C:\\Users\\RB-MU_Robot_VPC_01\\Downloads\\";
			String morongwa_path = "";
			//String MAFolder_path = "Q:\\CORPORATE ENTITY\\Year 2020\\Sybrin Echannel\\";
			//String reports201_path = "Q:\\ROBOTICS\\201 REPORTS\\"; 
			//String Dir = "Q:\\ROBOTICS\\SFI Refund\\" 
		
			//swift cmp
			String[] bombaclak;
			ArrayList bombaclakos = new ArrayList();
			

			ArrayList<IBK> swift = new ArrayList<IBK> ();
			ArrayList<IBK> ebox = new ArrayList<IBK> ();
			ArrayList<IBK> folder201 = new ArrayList<IBK>();
			ArrayList<IBK> report = new ArrayList<IBK>();
			
			
			Double swiftAmount = 0.0;
			String swiftBOName = "";
			String swiftAccNum = "";
			boolean listing = false;
			
			
			//LIST OF PUB_HO
			List dateList = new ArrayList();
			for(int i = 0; i < ph.size(); i++){
				date = ph.get(i).getAt("Date").toString();	
				dateList.add(date);
			}
			
			//PREVIOUS AND SECOND PREVIOUS WORKING DATES
			pwd = previousWorkingDate(karanLocal,dateList);
			second_pwd = previousWorkingDate(pwd,dateList);

			log.info("Current Day: "+karanLocal);
			//PWD CHANGES 
			log.info("Previous Working Day: "+pwd);
			log.info("Second Previous Working Day: "+second_pwd);
			
			//path
			String daily_path =  Dir+yearlyFolderStr+"//"+monthlyFolderStr+"//"+dailyFolderStr+"//";
			String monthly_path = Dir+yearlyFolderStr+"//"+monthlyFolderStr+"//";
			String config_path = Dir+"config\\";
			String log_path = daily_path+"log.txt";
			String morongwaFileDailyPath = daily_path+tayme+".xlsx"
			
			//LOG FILE
			FileWriter fr = new FileWriter(daily_path+"log.txt", true);
			BufferedWriter loginta = new BufferedWriter(fr);
			
			loginta.append("----------------------------------------------------");
			loginta.newLine();
			loginta.append("--COMPARE--");
			loginta.newLine();
			loginta.newLine();
			
			/////////////////////////////////////////////////////////SWIFT MESSAGE PRESENCE/////////////////////////////////////////////////////////////////
			File downloadFolder = new File(download_path);
			File[] downloadFiles = downloadFolder.listFiles();
			for(File file : downloadFiles){
				if(file.getName().contains("Morongwa_export")){
					morongwa_path = file.toPath();
				}
			}
			morongwa_path = morongwa_path.replace("\\","\\\\"); 
			
			File morongwaFile = new File(morongwa_path);
			/////////////////////////////////////////////////////////SWIFT MESSAGE PRESENCE/////////////////////////////////////////////////////////////////
			if(morongwaFile.exists()){
		 	//////////////////////////////////////////////////////////READ SWIFT MESSAGE//////////////////////////////////////////////////////////////////
			
			
			FileInputStream fisi1 = new FileInputStream(morongwaFile);
			XSSFWorkbook outputWorkbook1 = new XSSFWorkbook(fisi1);
			XSSFSheet outputSheet1 = outputWorkbook1.getSheetAt(0);	
			
			int outputRowCount1 = outputSheet1.getLastRowNum();
			int currentRowIndex1=1;//CHANGE
			
			Iterator rowIterator1 = outputSheet1.iterator();
			
			xlsRecord: while(rowIterator1.hasNext()){
			
				//reinitialise arrays and variables
				bombaclak = new String[0];
				swiftAccNum = "";
				swiftBOName = "";
				swiftAmount = 0.0;
				listing = false;
				
				Row currentRow1 = outputSheet1.getRow(currentRowIndex1);
				if(currentRow1 == null){
					break;
				}
			
				Cell cellData1 = currentRow1.getCell(15,Row.MissingCellPolicy.RETURN_BLANK_AS_NULL); //column 18 "Fin Format"
				DataFormatter formatter1 = new DataFormatter();
				value1 = formatter1.formatCellValue(cellData1);

				if(value1.contains("IBK FILE")){
					//println("----------------------------")
					
					//sleep(5000)
					//println("eyebeeks foundos")
					//println("IBK->"+currentRowIndex1);
					
					//delimiters(remove start and end of swift message tag)
					int startIndex = value1.indexOf(":20:")
					int endIndexNarrative = value1.indexOf(":21:");
					int endIndex = value1.indexOf("-}");
					String deb_narrative = value1.substring(startIndex+4,endIndexNarrative-1);
					value1 = value1.substring(startIndex+1,endIndex-1);
					bombaclak = value1.split(":");
					
					//println(deb_narrative)
					
					//SEARCH FOR AMOUNT & NARRATIVE
					for(int i = 0; i < bombaclak.size(); i++){
						
						if(bombaclak[i].contains("MUR") && bombaclak[i-1].contains("32A")){
							int amountIndex = bombaclak[i].indexOf("R");
							String amountStr = bombaclak[i].substring(amountIndex+1, bombaclak[i].length());
							amountStr = amountStr.replace(",",".");
							swiftAmount = Double.parseDouble(amountStr);
							//println(swiftAmount);
							

						}
					}
					
					//SEARCH FOR ACCOUNT DETAILS
					String accountDetailsRaw = bombaclak[bombaclak.size()-1].trim();
					//accountDetailsRaw = accountDetailsRaw.replace("//","");
					String[] accountDetailsRawArr = accountDetailsRaw.split("\\r?\\n");
					for(int i = 0; i < accountDetailsRawArr.size(); i++){
						
						//println(accountDetailsRawArr[i])
						
						//LISTING TO FOLLOW(will receive transactions by mail->skip)
						if(accountDetailsRawArr[i].contains("LISTINGS")){
							//continue xlsRecord;
							listing = true;
							break;
						}
						
						//REMOVE DUPLICATES------->PUT IN SAME CASE
						
						//by order of(name of person..)
						if(accountDetailsRawArr[i].contains("//BO ")){

							int nameIndex = accountDetailsRawArr[i].indexOf("//BO");
							String name = accountDetailsRawArr[i]
							name = name.substring(nameIndex+4, name.length());
							swiftBOName = name.trim();
							if(!accountDetailsRawArr[i+1].contains("//IFO")){
								swiftBOName += accountDetailsRawArr[i+1].trim();
								if(!accountDetailsRawArr[i+2].contains("//IFO")){
									swiftBOName += accountDetailsRawArr[i+1].trim();
								}
								swiftBOName = swiftBOName.replace("//","");
							}
							//println(swiftBOName)
							
						}
						//by order of(name of person..)
						if(accountDetailsRawArr[i].contains("//B/O ")){

							int nameIndex = accountDetailsRawArr[i].indexOf("//B/O");
							String name = accountDetailsRawArr[i]
							name = name.substring(nameIndex+4, name.length());
							swiftBOName = name.trim();
							if(!accountDetailsRawArr[i+1].contains("//IFO")){
								swiftBOName += accountDetailsRawArr[i+1].trim();
								if(!accountDetailsRawArr[i+2].contains("//IFO")){
									swiftBOName += accountDetailsRawArr[i+1].trim();
								}
								swiftBOName = swiftBOName.replace("//","");
							}
							//println(swiftBOName)
							
						}
						
						//ACCOUNT NUMBER
						//invalid credit account number
						if(accountDetailsRawArr[i].contains("INVALID CREDIT ACCOUNT")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf("-");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+1,accountDetailsRawArr[i].length());
							partOne = partOne.trim();
							String partTwo = accountDetailsRawArr[i+1].trim();
							swiftAccNum = partOne + partTwo;
							//println(swiftAccNum);
							
						}
						//credit account is closed
						if(accountDetailsRawArr[i].contains("CREDIT ACCOUNT IS CLOSED")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf("-");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+1,accountDetailsRawArr[i].length());
							partOne = partOne.trim();
							String partTwo = accountDetailsRawArr[i+1].trim();
							swiftAccNum = partOne + partTwo;
							//println(swiftAccNum)
							
						}
						//ac no. is invalid
						if(accountDetailsRawArr[i].contains("AC NO.")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf(".");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+1,accountDetailsRawArr[i].length());
							partOne = partOne.trim();
							swiftAccNum = partOne;
							//println(swiftAccNum)
							
						}
						//A/C NO.
						if(accountDetailsRawArr[i].contains("A/C NO.")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf(".");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+1,accountDetailsRawArr[i].length());
							partOne = partOne.trim();
							swiftAccNum = partOne;
							//println(swiftAccNum)
							
						}
						//acc not found
						if(accountDetailsRawArr[i].contains("ACC") && accountDetailsRawArr[i].contains("NOT FOUND")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf("ACC");
							int partTwoIndex = accountDetailsRawArr[i].indexOf("NO");
							String partOne 	 = accountDetailsRawArr[i].substring(partOneIndex+3,partTwoIndex-1);
							partOne = partOne.trim();
							swiftAccNum = partOne;
							//println(swiftAccNum)
							
						}
						//inactive credit account
						if(accountDetailsRawArr[i].contains("INACTIVE CREDIT ACCOUNT")){
							int partOneIndex = accountDetailsRawArr[i].indexOf("-");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+1,accountDetailsRawArr[i].length());
							String partTwo = accountDetailsRawArr[i+1].trim();
							swiftAccNum = partOne + partTwo;
							//println(swiftAccNum)
						}
						//acc no is invalid
						if(accountDetailsRawArr[i].contains("ACC NO")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf("NO");
							int partTwoIndex = accountDetailsRawArr[i].indexOf("IS");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+2,partTwoIndex-1);
							partOne = partOne.trim();
							swiftAccNum = partOne;
							//println(swiftAccNum)
							
						}
						//ACC xxx INVALID IN OUR BOOKS
						if(accountDetailsRawArr[i].contains("INVALID IN OUR")){
							
							int partOneIndex = accountDetailsRawArr[i].indexOf("ACC");
							int partTwoIndex = accountDetailsRawArr[i].indexOf("INVALID");
							String partOne = accountDetailsRawArr[i].substring(partOneIndex+3,partTwoIndex-1);
							partOne = partOne.trim();
							swiftAccNum = partOne;
							//println(swiftAccNum)
							
						}

						
						
					}
					//add account details in IBK class record
					if(!listing){
						swiftAccNum = swiftAccNum.replace("//","");
						swift.add(new IBK(swiftAccNum.trim(),swiftAmount,deb_narrative,"",swiftBOName,"","",""));
					}
					
				}
				
				currentRowIndex1++;
			}
			
			Iterator itr2=swift.iterator();
			while(itr2.hasNext()){
				IBK st=(IBK)itr2.next();
				println("SWIFT-->"+st.cred_account_num+" "+st.bo_name+" "+st.amount)
			}
			log.info("Number of IBK records found in Morongwa Query Excel- "+ swift.size());
			loginta.append("Number of IBK records found in Morongwa Query Excel- ");
			loginta.append(swift.size().toString());
			loginta.newLine();
			
			
			//////////////////////////////////////////////////////////READ SWIFT MESSAGE//////////////////////////////////////////////////////////////////
		 	if(swift.size() > 0){ 
			///////////////////////////////////////////////////////////READ MA MESSAGE////////////////////////////////////////////////////////////////////
			String MAFileDatePart = karanLocal.format(MAFileDateFormat);
			String MAFilePwdDatePart = pwd.format(MAFileDateFormat);
			String MAFileSecondPwdDatePart = second_pwd.format(MAFileDateFormat);
			String eboxDate = "";
			String MADateBo = "";
			
			log.info("SEARCHING IN MA FILES");
			File MAFolder = new File(MAFolder_path);
			File[] MAFiles = MAFolder.listFiles();
			MAFiles.sort(Comparator.reverseOrder()); //get last date first
			for(File file : MAFiles){
				if(file.getName().contains("MA06"+MAFileDatePart) || file.getName().contains("MA06"+MAFilePwdDatePart) || file.getName().contains("MA06"+MAFileSecondPwdDatePart)){
					log.info("Searching in "+file.getName());
					
					if(file.getName().contains("MA06"+MAFileDatePart)){
						eboxDate = karanLocal.format(eboxDateFormat);
						MADateBo = karanLocal.format(MAFileBODateFormat);
					}
					if(file.getName().contains("MA06"+MAFilePwdDatePart)){
						eboxDate = pwd.format(eboxDateFormat);
						MADateBo = pwd.format(MAFileBODateFormat);
					}
					if(file.getName().contains("MA06"+MAFileSecondPwdDatePart)){
						eboxDate = second_pwd.format(eboxDateFormat);
						MADateBo = second_pwd.format(MAFileBODateFormat);
					}
					
					
					Scanner myReader = new Scanner(file);
					myReader.nextLine();  //header
					while(myReader.hasNextLine() && myReader != null){ //read each line of MA
						
						String raw_status = myReader.nextLine(); 
						String swiftSearchRefTrimmed = "";
						
						int startBo = raw_status.indexOf(" ");
						int endBo = raw_status.indexOf(MADateBo);
						//println(endBo)
						
						if(endBo != -1){ //skip last line
						
							String boRaw = raw_status.substring(startBo,endBo);
							boRaw = boRaw.trim();
							//println(boRaw)
							
							String bo = boRaw.substring(12,boRaw.length()); //remove account number and ref xxxxx
							//println(bo)
							
							//check if record matches with account details of swift ibk-for each record 
							Iterator itr=swift.iterator();  //loop through arraylist  
							while(itr.hasNext()){
								IBK st=(IBK)itr.next();  //loop through IBK records
								
								boolean matchedBO = false;
								
								ArrayList boNameArr = new ArrayList();
								
								//validation Account Number
								if(st.bo_name.isEmpty()){
									swiftSearchRefTrimmed = st.cred_account_num.replaceFirst('^0+(?!$)', "");
									if(raw_status.contains(swiftSearchRefTrimmed)){
										matchedBO = true;
									}
									
								}
								//validation BO
								else{
									ArrayList boNameArrTmp = st.bo_name.split("\\s+");
									
									
									//println(boNameArrTmp)
									
									
									for(int i =0; i < boNameArrTmp.size(); i++){
										//remove all one letter
										String tempBO = boNameArrTmp[i].trim();
										if(boNameArrTmp.size() > 4){ //if bo name has more than 4 words
											//skip 3-letters word
											if(tempBO.length() > 3){
												boNameArr.add(tempBO);
											}
										}
										else{
											//skip 2-letters word
											if(tempBO.length() > 2){
												boNameArr.add(tempBO);
											}
										}
										
									}
									LinkedHashSet<String> tempArr = new LinkedHashSet<>(boNameArr);
									boNameArr = new ArrayList<>(tempArr);
									//println(boNameArr)
									
									//match bo name by parts
									int count = 0;
									for(int i = 0; i < boNameArr.size(); i++){
										String temp = boNameArr[i].toUpperCase().trim();
										String boCaps = bo.toUpperCase();
										if(boCaps.contains(temp)){
											//println("matched "+boNameArr[i])
											count++;
										}										
									}
									//println("COUNT-->"+count)
									
									if(boNameArr.size() == 1){
										if(count == 1){
											matchedBO = true;
											//println("MATCHED BO-->"+st.bo_name)
											//println("BO DETAILS-->"+bo)
											//println("BO ARRAY-->"+boNameArr);
										}
									}
									else if(boNameArr.size() > 1 && boNameArr.size() <= 3){
										if(count >= 2){
											matchedBO = true;
											//println("MATCHED BO-->"+st.bo_name)
											//println("BO DETAILS-->"+bo)
											//println("BO ARRAY-->"+boNameArr);
										}
									}
									else if(boNameArr.size() == 4){
										if(count >= 3){
											matchedBO = true;
											//println("MATCHED BO-->"+st.bo_name)
											//println("BO DETAILS-->"+bo)
											//println("BO ARRAY-->"+boNameArr);
										}
									}
									else if(boNameArr.size() >= 5 && boNameArr.size() < 7){
										if(count >= 5){
											matchedBO = true;
											//println("MATCHED BO-->"+st.bo_name)
											//println("BO DETAILS-->"+bo)
											//println("BO ARRAY-->"+boNameArr);
										}
									}
									else if(boNameArr.size() >= 7){
										if(count >= 6){
											matchedBO = true;
											//println("MATCHED BO-->"+st.bo_name)
											//println("BO DETAILS-->"+bo)
											//println("BO ARRAY-->"+boNameArr);
										}
									}
									
								} 
								 
								if(matchedBO){ //missing screnario-> where there is no acc number or name in swift, then there will be a blank space 
									//println(swiftSearchRefTrimmed)
									//parse branch code and account no of destination
									ArrayList<String> trans_details = raw_status.split("\\s+");
									//println(trans_details)
									String dest_branch_raw = trans_details[0];
									//println(dest_branch_raw)
									String dest_branch = dest_branch_raw.substring(dest_branch_raw.length()-2,dest_branch_raw.length());
									String dest_acc_raw = "";
									String dest_acc = "";
									
									dest_acc_raw = trans_details[1];
									if(trans_details[1] != null || trans_details[1] != ""){
										dest_acc = dest_acc_raw.substring(0,7);
									}
									else{
										println("No Account number found for "+st.bo_name); //test if will get error if account blank(array will remove blank space-->array size will decrease) 
									}

									//parse amount and currency
									int lastBlankIndex = raw_status.lastIndexOf(" "); 
									String amount_currency = raw_status.substring(lastBlankIndex+1,raw_status.length());
									String amount_raw = amount_currency.substring(3,amount_currency.length()); //need to test more length of currency
									if(amount_currency.contains("MUR")){
										amount_bd = new BigDecimal(amount_raw);
										amount_bd = amount_bd.movePointLeft(2);
										double amount = amount_bd.doubleValue();
										
										//parse amount from IBK record
										
										
										if(st.amount == amount){
											//println(raw_status)
											//to make a search on ebox(MA only)
											println("MATCHED BO-->"+st.bo_name)
											println("BO DETAILS-->"+bo)
											println("BO ARRAY-->"+boNameArr);
											
											println("MA bo and amount matched")
											ebox.add(new IBK(st.cred_account_num,amount,st.deb_narrative,"",st.bo_name,eboxDate,dest_acc,dest_branch)); //add cr narrative
										}
									}
								} 
							}
						}
					}
				}
			}
			if(ebox.size()>0){
				loginta.append("Records found in MA Files");
				loginta.newLine();
				Iterator eboxItr2=ebox.iterator();   
				while(eboxItr2.hasNext()){
					IBK st=(IBK)eboxItr2.next();
					println("EBOX-->"+st.cred_account_num+" "+st.bo_name+" "+st.amount+" "+st.ebox_branch+" "+st.ebox_acc_num);
					loginta.append(st.cred_account_num+"\t"+st.bo_name+"\t"+st.amount+"\t"+st.ebox_branch+"\t"+st.ebox_acc_num);
					loginta.newLine();
				}
			}
			
			log.info("Number of records found in MA Files- "+ebox.size());
			loginta.append("Number of records found in MA Files- ");
			loginta.append(ebox.size().toString());
			loginta.newLine();
			
			//compare ibk records found in swift file and ibk found in ma, find difference to search in 201 folder
			Iterator swiftItr=swift.iterator();   
			while(swiftItr.hasNext()){
				boolean found = false;
				String eboxDateStr;
				IBK st=(IBK)swiftItr.next();
				//println(st.cred_account_num)
				Iterator eboxItr=ebox.iterator();
				while(eboxItr.hasNext()){
					IBK sts=(IBK)eboxItr.next();
					//println(sts.cred_account_num)
					if(sts.cred_account_num == st.cred_account_num && sts.amount == st.amount ){ 
						found = true;
						eboxDateStr = sts.ebox_date;
					}					
				}
				if(!found){
					folder201.add(new IBK(st.cred_account_num,st.amount,st.deb_narrative,"",st.bo_name,eboxDateStr,"",""));
				}
			} 
			
			log.info("Number of records to search in 201 Files- "+folder201.size());
			loginta.append("Number of records to search in 201 Files- ");
			loginta.append(folder201.size().toString());
			loginta.newLine();
			
		 	   
			///////////////////////////////////////////////////////////READ MA MESSAGE////////////////////////////////////////////////////////////////////
	 		///////////////////////////////////////////////////////////READ 201 MESSAGE///////////////////////////////////////////////////////////////////
			String reports201FolderDate = karanLocal.format(reports201DateFormat).toUpperCase();
			String reports201subFolderDate = karanLocal.format(reports201subDateFormat);
			String reports201pwdFolderDate = pwd.format(reports201DateFormat).toUpperCase();
			String reports201pwdsubFolderDate = pwd.format(reports201subDateFormat);
			String reports201SecondpwdFolderDate = second_pwd.format(reports201DateFormat).toUpperCase();
			String reports201SecondpwdsubFolderDate = second_pwd.format(reports201subDateFormat);
			
			
			log.info("SEARCHING IN .201 FILES");
			File folder201Reports = new File(reports201_path);
			File[] folder201Month = folder201Reports.listFiles();
			for(File file : folder201Month){
				if(file.getName().equals(reports201FolderDate) || file.getName().equals(reports201pwdFolderDate) || file.getName().equals(reports201SecondpwdFolderDate)){
					File[] folder201Date = file.listFiles();
					//folder201Date.sort(Comparator.reverseOrder()); //get last date first[if previous working days in another month, it will cause problems]
					for(File datefile : folder201Date){
						if(datefile.getName().equals(reports201subFolderDate) || datefile.getName().equals(reports201pwdsubFolderDate) || datefile.getName().equals(reports201SecondpwdsubFolderDate)){
							//PROCESS ALL .201 AND SEARCH FOR RECORDS
							//201 Reports dated folder e.g 31
							//if all records found skip folder
							if(report.size() != folder201.size()){		
								if(file.exists()){
									String date = file.getName()+ "-"+datefile.getName();
									log.info("Searching in 201 Folder for "+ date);
									File[] folder201Folder = datefile.listFiles();
									for(File folder: folder201Folder){
										//sub folder e.g 31 MNS
										File[] folder201SubFolder = folder.listFiles();
										for(File subfolder: folder201SubFolder){
											if(subfolder.getName().contains("Reports")){
												//reports folder 
												File[] reportsFolder = subfolder.listFiles();
												for(File reports: reportsFolder){
													File[] subReportsFolder = reports.listFiles();
													for(File reportsSub:subReportsFolder){
														if(reportsSub.getAbsolutePath().contains(".201")){
															Scanner myReader = new Scanner(reportsSub);
															myReader.nextLine();  //header
															while(myReader.hasNextLine() && myReader != null){
																String raw_status = myReader.nextLine();
																String swiftSearchRefTrimmed = "";
																boolean match_found = false;
																
																Iterator itr=folder201.iterator();
																while(itr.hasNext()){
																	IBK st=(IBK)itr.next();
																	//for(int i = 0; i < swiftSearchRefArr.size(); i++){
																	if(!match_found){
																		//swiftSearchRefTrimmed = st.cred_account_num.replaceFirst('^0+(?!$)', "");
																		
																		boolean matchedBO = false;
							
																		//validation Account Number
																		swiftSearchRefTrimmed = st.cred_account_num.replaceFirst('^0+(?!$)', "");
																		if(raw_status.contains(swiftSearchRefTrimmed)){
																			matchedBO = true;
																		}
																			
																												
																		if(matchedBO){
																			String cred_acc_raw = "";
																			String cred_branch_raw = "";
																			String cred_acc = "";
																			String cred_branch = "";
																			
																			//println(reportsSub.getAbsolutePath())
																			//println(st.cred_account_num)
																			ArrayList status = raw_status.split("\\s+");
																			//process date
																			String date201RawStr = status[status.size()-2];
																			//println(date201RawStr)
																			LocalDate date201 = LocalDate.parse(date201RawStr,file201DateFormat);
																			String date201Str = date201.format(eboxDateFormat);
																			String credit_narrative = "REFUND "+date201Str;
																			//search for amount's position in array
																			int amount_index = 0;
																			for(int j =0; j < status.size(); j++){
																				if(status[j].contains("DR") || status[j].contains("CR")){
																					amount_index = j;
																				}
																			}
																			//parse amount
																			String amount_currency = status[amount_index].trim();
																			String amount_str = amount_currency.substring(0,amount_currency.length()-2)
																			amount_str = amount_str.replace(",","");
																			double amount = Double.parseDouble(amount_str);
																			
																			//parse credit branch and account num
																			cred_branch_raw = status[7];
																			cred_acc_raw = status[8];
																			if(cred_branch_raw != null && cred_acc_raw != null){
																				cred_branch = cred_branch_raw.substring(cred_branch_raw.length()-2,cred_branch_raw.length());
																				cred_acc = cred_acc_raw.substring(cred_acc_raw.length()-7,cred_acc_raw.length());
																			}
																			
																			if(st.amount == amount){
																				println("201 amount and bo matched")
																				match_found = true;
																				//println(raw_status)
																				//println(reportsSub.getAbsolutePath())
																				//println(st.cred_account_num)
																				report.add(new IBK(st.cred_account_num,st.amount,st.deb_narrative,credit_narrative,st.bo_name,"",cred_acc,cred_branch)); 
																				
																				
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
								else{
									log.info("201 Folder does not exist for "+ file.getName()+ "-"+datefile.getName());
								}
								
								
								
							
								
							}
						}
					}
				}
			}
			
			if(report.size()>0){
				loginta.append("Records found in 201 Files");
				loginta.newLine();
				Iterator Itr201=report.iterator();   
				while(Itr201.hasNext()){
					IBK st=(IBK)Itr201.next();
					loginta.append(st.cred_account_num+"\t"+st.bo_name+"\t"+st.amount);
					loginta.newLine();
				}
			}
			
			//////////////////////////////////////////////////////////READ 201 MESSAGE////////////////////////////////////////////////////////////////////
			log.info("Number of records found in 201 Files- "+report.size());
			loginta.append("Number of records found in 201 Files- ");
			loginta.append(report.size().toString());
			loginta.newLine();
		 	  
		 	///////////////////////////////////////////////////////////////EBOX//////////////////////////////////////////////////////////////////////////
			//if records found of MA files, go through ebox 
			if(ebox.size() > 0){
			
				log.info("SEARCHING ON EBOX");
				
				//LOGIN EBOX
				openChrome(ebox_portal);
				pageLoadTimeout(100000);
				$(byXpath("//input[@name='username']")).sendKeys(ebox_login);
				$(byXpath("//input[@name='j_password']")).sendKeys(ebox_pass);
				//$(byText("corp.dsarena.com")).click();//domain only present in uat
				pageLoadTimeout(30000);
				$(byXpath("/html/body/div[2]/form/div[2]/input")).click();//login
				
				//TRANSACTION SEARCH
				boolean ebox_load = false;
				try{
				ebox_load = $(byText("Transaction Search")).is(VISIBLE);
				}catch(Exception e){
					refresh();
					pageLoadTimeout(100000);
					$(byText("Transaction Search")).click();
				}
				
				if(ebox_load){
					$(byText("Transaction Search")).click();
				}
				
				DecimalFormat eboxFormat = new DecimalFormat("#.##");
				
				Iterator itr=ebox.iterator();
				while(itr.hasNext()){
					IBK st=(IBK)itr.next();
					
					log.info("Searching for Acc Num: "+st.cred_account_num);

				
					$(byXpath('//*[@id="first"]/form/table/tbody/tr/td[2]/select/option[4]')).click(); //originator
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[1]/td[2]/input')).clear(); //branch id clear
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[1]/td[2]/input')).sendKeys(st.ebox_branch); //branch id
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[2]/td[2]/input')).clear(); //acc number clear
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[2]/td[2]/input')).sendKeys(st.ebox_acc_num); //acc number
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[3]/td[2]/input[1]')).clear(); //amount 1 clear
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[3]/td[2]/input[1]')).sendKeys(String.format("%.2f", st.amount)); //amount 1
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[3]/td[2]/input[2]')).clear(); //amount 2 clear
					$(byXpath('//*[@id="originator"]/form/table/tbody/tr[3]/td[2]/input[2]')).sendKeys(String.format("%.2f", st.amount)); //amount 2
					$(byXpath('//*[@id="originator"]/form/div[1]/input')).click(); //search
					
					
					//COUNT NUMBER OF ROWS
					boolean rowExists = true;
					int i = 2;
					int running_bal_row_count;
					int row_count = 0;
					while(rowExists){
						
						try{
							rowExists = $(byXpath("//*[@id='search-results']/tbody/tr["+i+"]/td[2]")).is(EXIST);	//check by date column
						}
						catch(Exception e){
							rowExists = false;
						}
						if(rowExists){
							row_count++;
							i++;
						}
						
						
					}//END OF ROWS
					int row = i - 1;
					boolean creditPass = true;
					//println("Number of Transactions: "+row_count);
					//println("Last Row Item Number: "+ row);
					
					String eboxTransDate = "";
					String eboxType = "";
					boolean found = false;
					//GO THROUGH EACH RECORD TO FIND CORRESPONDING DATE 
					while(row >= 2){
						
						//enter on transaction with corresponding date
						eboxTransDate = $(byXpath('//*[@id="search-results"]/tbody/tr['+row+']/td[7]')).text();
						eboxType = $(byXpath('//*[@id="search-results"]/tbody/tr['+row+']/td[3]')).text();
						//BIR exception
						LocalDate birDate = LocalDate.parse(st.ebox_date,eboxDateFormat);
						LocalDate previous_birDate = previousWorkingDate(birDate,dateList); //calculate one working day before date found on MA file
						String eboxTransPwdDate = previous_birDate.format(eboxDateFormat);
						
						
						if(eboxTransDate.equals(st.ebox_date) || (eboxType.equals("BIR") && eboxTransDate.equals(eboxTransPwdDate)) || (eboxType.equals("ECH") && eboxTransDate.equals(eboxTransPwdDate)) || (eboxType.equals("AAH") && eboxTransDate.equals(eboxTransPwdDate))|| (eboxType.equals("AAO") && eboxTransDate.equals(eboxTransPwdDate))){
							
							//println("date matched")
							$(byXpath('//*[@id="search-results"]/tbody/tr['+row+']/td[1]/a')).click(); //click on info
							
							sleep(3000)
							
							//compare if ebox records match with MA files records
							String branch = $(byXpath('/html/body/div[3]/div[4]/table[2]/tbody/tr[2]/td[5]')).text();
							String acc = $(byXpath('/html/body/div[3]/div[4]/table[2]/tbody/tr[2]/td[6]')).text();
							String amt_str = $(byXpath('/html/body/div[3]/div[4]/table[2]/tbody/tr[2]/td[7]')).text();
							amt_str = amt_str.replace(",","");
							double amt = Double.parseDouble(amt_str);
							String acc_counterparty = $(byXpath('/html/body/div[3]/div[5]/table[2]/tbody/tr[2]/td[7]')).text();
							
							//VALIDATIONS
							if(amt.equals(st.amount)){ //amount
								if(acc.contains(st.ebox_acc_num)){ //originator account number
									if(branch.equals(st.ebox_branch)){ //originator branch
										
										if(!acc_counterparty.isEmpty()){
											println("acc_counterparty-->"+acc_counterparty)
											//last check--account number of counterparty(from swift)
											acc_counterparty = acc_counterparty.substring(0,acc_counterparty.length()-4) //remove MUR + 1 additional 
											acc_counterparty = acc_counterparty.substring(acc_counterparty.length()-6,acc_counterparty.length()) //take only first 6 digits to compare
											acc_counterparty = acc_counterparty.replaceFirst('^0+(?!$)', "");
											println(st.cred_account_num)
											println(acc_counterparty)
											if(st.cred_account_num.contains(acc_counterparty)){ //if counterparty from ebox matches that of swift message
												log.info("Record Matched");
												String credit_narrative = "REFUND "+eboxTransDate;
											
												report.add(new IBK(st.cred_account_num,st.amount,st.deb_narrative,credit_narrative,st.bo_name,"",st.ebox_acc_num,st.ebox_branch)); //add cr narrative
											}
											else{
												log.info("Record with same date found");
											}
										}
									}
									else{
										log.info("Branch Number does not match");
									}
								}
								else{
									log.info("Acount Number does not match");
								}
							}
							else{
								log.info("Amount does not match");
							}
							
							//return to search page
							//$(byXpath('/html/body/div[3]/div[8]/input')).click(); //ok
							$(byAttribute('value','OK')).click(); // OK
							found = true;
							
						} 
						
						
						
						
						
						row--;
					}
					if(found){
						//return to query
						//$(byXpath('/html/body/div[3]/div[2]/form[1]/input')).click(); //search again
						$(byAttribute('value','Search Again')).click(); // SEARCH AGAIN
					}
					else if(!found){
						log.info("No Transaction found for post date: "+st.ebox_date);
						//$(byXpath('/html/body/div[3]/div[2]/form[1]/input')).click(); //search again
						$(byAttribute('value','Search Again')).click(); // SEARCH AGAIN
					}
				
				}
			}
			 
			///////////////////////////////////////////////////////////////EBOX//////////////////////////////////////////////////////////////////////////
			log.info("Number of records found- "+report.size() + "/" + swift.size());
			loginta.append("Number of records found- ");
			loginta.append(report.size().toString());
			loginta.append("/");
			loginta.append(swift.size().toString());
			loginta.newLine();
		 
			//////////////////////////////////////////////////////////WRITE TO REPORT////////////////////////////////////////////////////////////////////
			try{
				//TO(DATE EXCEL)
				File outputFile2 = new File(monthly_path+dateExcel+".xlsx"); 
				FileInputStream fisi2 = new FileInputStream(outputFile2);
						
				XSSFWorkbook outputWorkbook2 = new XSSFWorkbook(fisi2);
				XSSFSheet outputSheet2 = outputWorkbook2.getSheetAt(0);	//change sheet name
				
				int outputRowCount2 = outputSheet2.getLastRowNum();//GET LAST OUTPUT EXCEL ROW
				
				String debit_branch = "23";
				String debit_acc = "9503284";
				Iterator itr=report.iterator();
				while(itr.hasNext()){
					IBK st=(IBK)itr.next();
				
					//date
					outputSheet2.createRow(outputRowCount2+1).createCell(0).setCellValue(karanLocal.toString());
					//debit branch
					outputSheet2.getRow(outputRowCount2+1).createCell(1).setCellValue(debit_branch);
					//debit account number
					outputSheet2.getRow(outputRowCount2+1).createCell(2).setCellValue(debit_acc);
					//debit narrative
					outputSheet2.getRow(outputRowCount2+1).createCell(3).setCellValue(st.deb_narrative);
					//credit branch
					outputSheet2.getRow(outputRowCount2+1).createCell(4).setCellValue(st.ebox_branch); 
					//credit account number
					outputSheet2.getRow(outputRowCount2+1).createCell(5).setCellValue(st.ebox_acc_num);
					//credit narrative
					outputSheet2.getRow(outputRowCount2+1).createCell(6).setCellValue(st.cred_narrative);
					//amount
					outputSheet2.getRow(outputRowCount2+1).createCell(7).setCellValue(st.amount);
					
					outputRowCount2++;
				}
				
				FileOutputStream fos2 = new FileOutputStream(outputFile2);
				fisi2.close();
				outputWorkbook2.write(fos2);
				fos2.close();
				
				log.info("Successfully written to Date Excel");
				

				//move morongwa swift to daily folder
				File morongwaFileDaily = new File(morongwaFileDailyPath);
				Files.move(morongwaFile.toPath(), morongwaFileDaily.toPath());//move
						
			}catch(Exception e){

				log.info("Failed to write to Date Excel "+e);
				//loginta.append("Failed to write to Date Excel");
				//loginta.newLine();
			} 
			//////////////////////////////////////////////////////////WRITE TO REPORT////////////////////////////////////////////////////////////////////
			}//swift size check
			else{
				log.info("No IBK records found in Morongwa Query");
				//move morongwa swift to daily folder
				File morongwaFileDaily = new File(morongwaFileDailyPath);
				Files.move(morongwaFile.toPath(), morongwaFileDaily.toPath());//move
			}
			}//morongwa file presence check
			else{
				log.info("Morongwa Query Excel is not found");
			}
			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			loginta.append("----------------------------------------------------");
			loginta.newLine();
			loginta.newLine();
			loginta.close(); 
			
			
			
			////////////////////////////////////////////////////////////DEFINITION//////////////////////////////////////////////////////////////////////
			class IBK{
				String cred_account_num;
				double amount;
				String deb_narrative;
				String cred_narrative;
				String bo_name;
				String ebox_date;
				String ebox_acc_num;
				String ebox_branch;
 
				IBK(String cred_account_num,double amount,String deb_narrative,String cred_narrative,String bo_name,String ebox_date,String ebox_acc_num,String ebox_branch){  
					this.cred_account_num=cred_account_num;    
					this.amount=amount;  
					this.deb_narrative=deb_narrative;  
					this.cred_narrative=cred_narrative;  
					this.bo_name=bo_name;  
					this.ebox_date=ebox_date;  
					this.ebox_acc_num=ebox_acc_num;  
					this.ebox_branch=ebox_branch;  
				}  
			} 
			
			//PREVIOUS WORKING DAY
			public previousWorkingDate(LocalDate date, List publicHolidaysList){
				DateTimeFormatter csvDateFormat   = DateTimeFormatter.ofPattern("M/d/yyyy");
				boolean validPwd = false;
				LocalDate pwd = date.minusDays(1);	
				while(!validPwd){
					
					String pwdCheck = pwd.format(csvDateFormat);
						 
					//PREVIOUS WORKING IS A NON-SUNDAY PUBLIC HOLIDAY
					if(publicHolidaysList.contains(pwdCheck) && pwd.getDayOfWeek().toString() != "SUNDAY"){
						pwd = pwd.minusDays(1);

					}
					//THE WEEKND
					else if(pwd.getDayOfWeek().toString() == "SUNDAY"){
						//SUNDAY
						if(pwd.getDayOfWeek().toString() == "SUNDAY"){
							pwd = pwd.minusDays(1);
						}
						
						//SATURDAY
						if(pwd.getDayOfWeek().toString() == "SATURDAY"){
							pwd = pwd.minusDays(1);
						}
					}
					//ALL OTHER SCENARIOS(NORMAL WORKING DAY)
					else{
						validPwd = true;
					}
					
					
				}
				return pwd;
			}
			
			////////////////////////////////////////////////////////////DEFINITION//////////////////////////////////////////////////////////////////////
			
			]]></script>
	
	</robot>
</robotics-flow>
	
    <export include-original-data="true"></export>

</config>